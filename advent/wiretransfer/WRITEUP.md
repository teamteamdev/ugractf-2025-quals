# Телеграфный перевод: Write-up

Нам дан текстовый файл с названием `rsa.txt`, содержащий три числа — `n`, `e` и `c`. Нетрудно догадаться, что в файле указан публичный ключ и зашифрованное сообщение в [криптосистеме RSA](https://ru.wikipedia.org/wiki/RSA).

Давайте разбираться, как в целом устроен RSA:
- Выбираются два простые числа $p$ и $q$
- $n$ — *модуль* RSA — это произведение двух этих чисел
- Выбирается число $e$, да не простое, а такое, что оно взаимно просто с $\phi(n)$ — функцией Эйлера. Обычно для произведения двух простых чисел это $(p - 1)(q - 1)$
- Ищется $d$ — обратное по модулю $\phi(n)$ к $e$
- Теперь мы можем шифровать любое число $m$ по формуле $c = m^e \mod n$. Для расшифровки нужно произвести обратную операцию: $m = c^d \mod n$.

Не зная разбиение числа $n$ на простые множители, посчитать $\phi(n)$ мы не сможем — обычно факторизация числа считается трудной задачей. А следовательно, не сможем и посчитать $d$, которое является частью приватного ключа.

Говорят, что сейчас можно нетрудно разложить на простые множители модули порядка 256–512 бит. В нашем случае бит в модуле — 4096, это можно проверить с помощью Python вызовом функции `math.log(n, 2)`.

Если долго смотреть на разные модули RSA из реальных примеров, можно заметить одну интересную особенность — все они нечётные. Почему? Потому что иначе $n$ будет делиться на 2. А если мы нашли множитель, то мы выиграли. Однако, в нашем случае ровно это и произошло — модуль заканчивается на 4, а значит, чётный.

Понадеемся, что второй делитель простой и попробуем всё восстановить как было.

- `p = 2`
- `q = 869046076735985989844849283148291817572482800763823953950976114088743397066216517793112271364066088724009437574333181617795644881949902526279378395977337842488408519116996975498569410711197470974613697668721656480591808887017169962892927616886167716385906938472767130746506183292526054776610698677560505511396141993682504773112690927033138856301841930143431000608742348625573385532936297018856104532198025164108310719722962577201619265808261411642004164971195671154217386870816122651381508613463986783009224241026513965672208335201446487258224811818634707127648265522878675055335460954802053447038833669863277338857019151256129576138692285023508642450618398576877308216812586979604890403799595552833156962029011190074042730056163963058815626503936936135357564321091872756145291641832698954637824178150877787289323924581760199921545604447205743846257257234917285978621745649623252478584297111328396600861948099005463412509628956263129472827220074153645895024274153451204588630170229178426124250967877462209945707248425064134137946561601516171332650855775271636476219656440318671000010674146821295714047460318593087559047737718496148881909716605480200571791427921193383191400979380560542599983729138381513326024413082964990394005605857`
- `phi(n) = (p - 1) * (q - 1) = 869046076735985989844849283148291817572482800763823953950976114088743397066216517793112271364066088724009437574333181617795644881949902526279378395977337842488408519116996975498569410711197470974613697668721656480591808887017169962892927616886167716385906938472767130746506183292526054776610698677560505511396141993682504773112690927033138856301841930143431000608742348625573385532936297018856104532198025164108310719722962577201619265808261411642004164971195671154217386870816122651381508613463986783009224241026513965672208335201446487258224811818634707127648265522878675055335460954802053447038833669863277338857019151256129576138692285023508642450618398576877308216812586979604890403799595552833156962029011190074042730056163963058815626503936936135357564321091872756145291641832698954637824178150877787289323924581760199921545604447205743846257257234917285978621745649623252478584297111328396600861948099005463412509628956263129472827220074153645895024274153451204588630170229178426124250967877462209945707248425064134137946561601516171332650855775271636476219656440318671000010674146821295714047460318593087559047737718496148881909716605480200571791427921193383191400979380560542599983729138381513326024413082964990394005605856`

Для поиска $d$ можно написать небольшую программу на Python — обратное по модулю ищется с помощью [расширенного алгоритма Евклида](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%B0):

```python
def extended_gcd(a, b):
    """
    Return a tuple of three values: gcd(a, b) and the coefficients x and y such that:
        a*x + b*y = gcd(a, b)
    """
    if a == 0:
        return (b, 0, 1)
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return (gcd, x, y)

def modinv(a, m):
    """
    Compute the modular inverse of a modulo m.
    Raises a ValueError if the modular inverse does not exist.
    """
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        raise ValueError(f"Modular inverse does not exist for a = {a} and m = {m}.")
    return x % m

def main():
    a = input()
    m = input()

    try:
        inverse = modinv(a, m)
        print(f"The modular inverse of {a} modulo {m} is {inverse}")
    except ValueError as e:
        print(e)

if __name__ == "__main__":
    main()
```

Можно также воспользоваться онлайн-калькуляторами. Второй вариант менее надёжен, чем первый, потому что большинство из них рассчитаны на довольно маленькие числа, но есть и [такие, которые работают](https://www.boxentriq.com/code-breaking/modular-multiplicative-inverse).

Оба варианта выдают нам `d = 448718284185559758767716784296733857436795176694798949871783583695454290146386022332440089578232637690644298000791316855586719367079706907346504807078095354562541097065780561421732613471111146685230524976911853359884435066111875953649599121531516995815839981857270960485390279329779958917645443528845841982393671497386549262513699868469328558804919802159445223760612056321479130766575085140013606379069059821600944908138995233988824546983929046318168041540813438457475352157125696543938521292872848143037507653571207197222665942214043176866976965792312431977241705556078115952782346815532396762048111640058340202779844531476206856080644647037711658328676564222392713013240171671007978491145070935690086492181511354821177837593581218944218715920269801514936060836801011370602873550329992217007024007269901787449584696948627239653099496603277464119710992684626486415774009354068712950284786150575119590102803938572804315362517879228344877412763783653283236060948976587810123665354385845686583434220394669327591326847116220535500464984635148171593536053047582539736618962636128347467375088918538929546174710617221897400104008371701347056089581461050162612705038824255960660601152650545313350334153383793765803124038547911138897763945505`.

Теперь мы можем расшифровать сообщение. Для эффективного возведения в степень, например, в Python нужно воспользоваться функцией `pow` с тремя аргументами: третий — это как раз модуль.

Получили

`m = 137862636049732281579614087880122894256794081303037627915844577665627278386857535972958675772871569226062867995011278768037100391524216486343639907276182393510092116280882122130248910650084014385897918012843130661014608533941255180051966191692720891272651015015915851782399252907178121585149458598008796049204017906186823412491607458307412565192096247379172575155536883254507703428890422898396699534864456725839567586877272066394426425833348462595491900706651999346029413130419116947283085937976816737020822969804243265121371566188292332301055875394370143821200660893861064992764507181050039563881349067787913616795509588232994340253708338862033775560911865604708299546694408115051478638815143948224375562476215698599194975784356826715243706083183856086679135063117691755834598589437348969421299636233257372726910940119487805181296779007881070599250640`

Как из этого получить флаг? На самом деле, нередко строки для использования в шифровании записывают в шестнадцатеричной форме — каждому байту сопоставляют по две шестнадцатеричных цифры. И дальше всё получившееся число преобразуют в удобную форму. В нашем случае у нас есть запись числа в десятичной системе счисления.

Переведём обратно в шестнадцатеричную:

```
hex(m) = 0xabbc28bd1bcd0b5d082d181d1b8d0a1d020b5d08bd1bdd082d1b8d0b4d0b5d080d19ad020bad0bdd0b0d091d020bad0bdd0b0d091d0abc2208fd1b8d086d1b0d080d1bed0bfd080d1bed09ad0208fd1b0d0b2d0bed081d1bdd0b0d0bdd0b8d0a4d0abc220bed0b2d082d181d1b5d089d1b1d0bed020b5d0bed0bdd080d1b5d0bdd0bed0b8d086d1bad0b0d020b5d0bed082d18bd180d1bad0b8d080d19fd00a73377867626f73636c66786e5f746e656d6f6d5f6b6e61625f6b6e61625f6465696669747265635f617267750a3aacd0a1d098d09fd094d09ed09fd020afd090d09dd09dd09ed0a0d0a2d09ad095d09bd0add00a0a8bd1bdd0b0d0bcd080d1b0d0bad020b8d088d1b0d0bdd0203a95d098d09dd095d0a7d090d09dd097d090d09dd00a8bd1bdd0b0d0bcd080d1b0d0bad020b8d088d1b0d0b2d0203a9ad098d09dd0a7d09ed0a2d0a1d098d00a0aafd098d0a6d09ad090d097d09dd090d0a0d0a2d0
```

Упс, в получившемся фрагменте 707 цифр — нечётное количество. Видимо, первый символ имел код меньше 16 — и первой шестнадцатеричной цифрой был ноль, который мы успешно потеряли.

Вернём как было и декодируем:

```
>>> bytes.fromhex('0abbc28bd1bcd0b5d082d181d1b8d0a1d020b5d08bd1bdd082d1b8d0b4d0b5d080d19ad020bad0bdd0b0d091d020bad0bdd0b0d091d0abc2208fd1b8d086d1b0d080d1bed0bfd080d1bed09ad0208fd1b0d0b2d0bed081d1bdd0b0d0bdd0b8d0a4d0abc220bed0b2d082d181d1b5d089d1b1d0bed020b5d0bed0bdd080d1b5d0bdd0bed0b8d086d1bad0b0d020b5d0bed082d18bd180d1bad0b8d080d19fd00a73377867626f73636c66786e5f746e656d6f6d5f6b6e61625f6b6e61625f6465696669747265635f617267750a3aacd0a1d098d09fd094d09ed09fd020afd090d09dd09dd09ed0a0d0a2d09ad095d09bd0add00a0a8bd1bdd0b0d0bcd080d1b0d0bad020b8d088d1b0d0bdd0203a95d098d09dd095d0a7d090d09dd097d090d09dd00a8bd1bdd0b0d0bcd080d1b0d0bad020b8d088d1b0d0b2d0203a9ad098d09dd0a7d09ed0a2d0a1d098d00a0aafd098d0a6d09ad090d097d09dd090d0a0d0a2d0')
b'\n\xbb\xc2\x8b\xd1\xbc\xd0\xb5\xd0\x82\xd1\x81\xd1\xb8\xd0\xa1\xd0 \xb5\xd0\x8b\xd1\xbd\xd0\x82\xd1\xb8\xd0\xb4\xd0\xb5\xd0\x80\xd1\x9a\xd0 \xba\xd0\xbd\xd0\xb0\xd0\x91\xd0 \xba\xd0\xbd\xd0\xb0\xd0\x91\xd0\xab\xc2 \x8f\xd1\xb8\xd0\x86\xd1\xb0\xd0\x80\xd1\xbe\xd0\xbf\xd0\x80\xd1\xbe\xd0\x9a\xd0 \x8f\xd1\xb0\xd0\xb2\xd0\xbe\xd0\x81\xd1\xbd\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xa4\xd0\xab\xc2 \xbe\xd0\xb2\xd0\x82\xd1\x81\xd1\xb5\xd0\x89\xd1\xb1\xd0\xbe\xd0 \xb5\xd0\xbe\xd0\xbd\xd0\x80\xd1\xb5\xd0\xbd\xd0\xbe\xd0\xb8\xd0\x86\xd1\xba\xd0\xb0\xd0 \xb5\xd0\xbe\xd0\x82\xd1\x8b\xd1\x80\xd1\xba\xd0\xb8\xd0\x80\xd1\x9f\xd0\ns7xgbosclfxn_tnemom_knab_knab_deifitrec_argu\n:\xac\xd0\xa1\xd0\x98\xd0\x9f\xd0\x94\xd0\x9e\xd0\x9f\xd0 \xaf\xd0\x90\xd0\x9d\xd0\x9d\xd0\x9e\xd0\xa0\xd0\xa2\xd0\x9a\xd0\x95\xd0\x9b\xd0\xad\xd0\n\n\x8b\xd1\xbd\xd0\xb0\xd0\xbc\xd0\x80\xd1\xb0\xd0\xba\xd0 \xb8\xd0\x88\xd1\xb0\xd0\xbd\xd0 :\x95\xd0\x98\xd0\x9d\xd0\x95\xd0\xa7\xd0\x90\xd0\x9d\xd0\x97\xd0\x90\xd0\x9d\xd0\n\x8b\xd1\xbd\xd0\xb0\xd0\xbc\xd0\x80\xd1\xb0\xd0\xba\xd0 \xb8\xd0\x88\xd1\xb0\xd0\xb2\xd0 :\x9a\xd0\x98\xd0\x9d\xd0\xa7\xd0\x9e\xd0\xa2\xd0\xa1\xd0\x98\xd0\n\n\xaf\xd0\x98\xd0\xa6\xd0\x9a\xd0\x90\xd0\x97\xd0\x9d\xd0\x90\xd0\xa0\xd0\xa2\xd0'
```

Кхем. Флаг, конечно, может и можно разглядеть, но нам интересно, что же там такого написано. Заметим, что текст _начинается_ символом переноса строки. А ещё он _заканчивается_ байтом `D0`, и вообще этот байт часто встречается.

В UTF-8 символы могут кодироваться разным количеством байт. Например, английская буква A кодируется одним байтом, русская буква А — двумя, а эмодзи 👋 — аж четырьмя. Байт `D0` знаменит тем, что часто встречается в _двухбайтовых_ последовательностях, соответствующих русским буквам. Но встречается он первым байтом, а не вторым.

В общем всё это должно намекнуть, что все исходные байты надо перевернуть, и ещё декодировать это всё как UTF-8:

```
>>> text = data[::-1].decode()
'ТРАНЗАКЦИЯ\n\nИСТОЧНИК: ваши карманы\nНАЗНАЧЕНИЕ: наши карманы\n\nЭЛЕКТРОННАЯ ПОДПИСЬ:\nugra_certified_bank_bank_moment_nxflcsobgx7s\nПрикрытое акционерное общество «Финансовая Корпорация «Банк Банк Кредитные Системы»\n'
```

Ура!

Флаг: **ugra_certified_bank_bank_moment_nxflcsobgx7s**

## Интересные факты

Райтап был написан с целью помочь разобраться в том, как работает RSA, и в нём специально вообще всё проделано руками. Разумеется, существуют готовые утилиты для поиска различных слабых параметров RSA, которые умеют автоматически делать всё то, о чём мы тут рассказали. Но при попытке запустить одну из таких утилит оказалось, что она не готова к двойке в качестве одного из простых множителей — и поэтому расшифровать текст она не смогла.
