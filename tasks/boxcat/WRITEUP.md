# Коробкошка: Write-up

Это задание — более сложная версия [Кошкоробки](../catbox/WRITEUP.md), прочитайте сначала её разбор.

Это задание отличается от предыдущего единственным местом: кошки поменяли местами ID и пароль. Теперь нам известны не старшие цифры `n`, а только младшие. Трюк с округлением больше не работает вообще.

Как решать задачу — непонятно, но давайте осознаем всю информацию об `n`, которая у нас есть.

В данном примере в качестве ID будет выступать `v6h3lyumrj9dfy3rpy5fpb4uu3yalerk`. «Последние 32 цифры числа `n` в тридцатишестеричной системе» можно переписать на математический язык как `n mod 36^32`, т.е.

- `n mod 36^32 = 54859482076950497419336215094705659602406289178624`.

Также нам известно, что все биты в `n`, кроме первых `53`, — это 0. Длина `n` в radix-36 — это `64` (сумма длины ID и фиксированной длины пароля `32`), то есть `n >= 36 ** 64`, поэтому бинарное представление `n` содержит хотя бы `331` бит, а значит, по меньшей мере последние `331 - 53 === 278` бит нулевые:

- `n mod 2^278 = 0`.

Люди, знающие теорию чисел, наверняка уже догадались, к чему идёт дело. [Китайская теорема об остатках](https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%82%D0%B0%D0%B9%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BE%D0%B1_%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B0%D1%85) (КТО) позволяет объединить эти два утверждения в одно и посчитать `n mod НОК(36^32, 2^278)`. Поскольку `n < 36^65`, а итоговый модуль `> 36^65`, это значение будет с точностью совпадать с `n`.

Осталось реализовать алгоритм КТО или найти библиотеку:

```python
# n = x (mod m1), n = 0 (mod m2)
m1 = 36 ** 32
x = 54859482076950497419336215094705659602406289178624
m2 = 2 ** 278

g = math.gcd(m1, m2)
assert x % g == 0
x //= g
m1 //= g
m2 //= g

n = (x * pow(m2, -1, m1)) % m1 * m2 * g
print(n)
```

```
3448302325623570559945097778409598065134011127432190820789138412852272926707266457933617528280449024
```

И перевести `n` в ID и пароль:

```javascript
> n = 3448302325623570559945097778409598065134011127432190820789138412852272926707266457933617528280449024n.toString(36)
"uxwrz26w7b2p8zw4ghtae32ffwjkyls4v6h3lyumrj9dfy3rpy5fpb4uu3yalerk"

> [n.substr(0, 32), n.substr(32)]
Array [ "uxwrz26w7b2p8zw4ghtae32ffwjkyls4", "v6h3lyumrj9dfy3rpy5fpb4uu3yalerk" ]
//      ^ пароль                            ^ ID
```

Флаг: **ugra_send_pics_please_fwtlc0q4t98t**


## О решаемости задания

На генерирующем сервере `Math.random()` был изменён, чтобы всегда возвращать число, меньшее либо равное 0.1, чтобы `n` гарантированно имело достаточно большую длину.

Для очень коротких `n` модуль, который в разборе был равен `2^278`, мог быть настолько низким, что `НОК` оказался бы меньше `36^(1 + длина n)`. Это случается с чрезвычайно низкой вероятностью, но, зная нашу везучесть, этот случай было решено не допускать вообще.
