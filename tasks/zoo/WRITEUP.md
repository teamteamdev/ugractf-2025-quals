# Зоопарк: Write-up

Нам дано приложение, в котором можно зарегистрироваться и купить билет в зоопарк, чтобы посмотреть на гоферов. Однако вот незадача: денег на покупку билета нам, конечно, не дали.

На сайте есть кнопка пополнения баланса, но какую бы карту мы ни выбрали, пополнение не работает.

В куку приложение складывает JWT-токен, в котором хранит ммя пользователя и текущую корзину. К сожалению, это тоже мало чем может помочь.

Попробуем поизучать все доступные поля на предмет инъекций или подобных вещей. Рано или поздно обращаем внимание, что хотя в поле «Количество билетов» при добавлении в корзину есть проверка на то, что пользователь вводит именно число; проверка на количество билетов (≤ 100) существует только на фронтенде — бекенд позволяет добавить любое число.

Тут стоит вспомнить, что бекенд написан на Go, в котором стандартный численный тип `int` ограничен сверху $2^{63}$. Вместе с тем, числа хранятся в памяти в формате [«дополнительного кода»](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4): отрицательные числа обозначаются старшим битом 1. Например, для восьмибитных чисел число −127 хранится как `1000000`.

Обратите внимание, что при таком способе хранения арифметическим операциям вообще не нужно знать про то, отрицательное число или нет: например, −1 + 1 = 11111111 + 00000001 = 00000000 = 0. Старшая единичка просто отбрасывается, потому что она не влезает в текущую битность числа.

Однако, о знаке числа совершенно точно знает операция сравнения. Давайте подумаем, как может быть реализована проверка, хватает ли нам денег: как правило, это что-то типа

```go
totalPrice := itemPrice * itemCount
if totalPrice > balance {
    // Денег не хватило, ошибка!
}
```

В этом случае, если `totalPrice` переполнится (ведь, поскольку арифметические операции «не знают» о знаках, при умножении двух положительных чисел в старший бит может проникнуть 1), проверка пройдёт успешно (поскольку по мнению процессора в `totalPrice` окажется отрицательное число), и покупка совершится.

Давайте считать: максимальное число билетов, при котором переполнения не произойдёт — $\dfrac{2^{63} - 1}{100} = 92233720368547758$ штук.

Если мы добавим ещё один билет, получим 92233720368547759 или `00000001 01000111 10101110 00010100 01111010 11100001 01000111 10101111` в двоичном представлении. Умножим это число на 100 (`1100100`), получим `10000000 00000000 00000000 00000000 00000000 00000000 00000000 01011100`. В типе `int` это уже не 9223372036854775900, а -9223372036854775716. Столько денег у нас есть.

Купив все билеты, получаем флаг (и бонусом — много денег на счету).

Флаг: **ugra_gophers_are_so_smart_theyre_building_their_own_integers_pe7x2kjj06n7**

## Постмортем

Было решение и проще — можно отправить POST-запрос в эндпоинт `/add-to-cart`, добавляющий ноль билетов: сервис проверял [только отрицательные](app/main.go#L533) количества билетов.

Если сделать так, то в корзине появлялась позиция с нулём билетов. С ней уже можно было пройти на кассу. Кнопки покупки не было, но можно было сделать запрос вручную, узнав правильный эндпоинт из корзины с билетами. Там проверялось только [число записей](app/main.go#L668) в корзине — и запись с нулём билетов тоже считалась.

Флаг выдавался за любую успешную покупку вне зависимости от того, сколько билетов было куплено.
