# Просеиватель: Write-up

В задании дан доступ к какой-то машине:

![](writeup/start.png)

Большой квадрат — это, вероятно, оперативная память или код программы. `r0`, `r1`, `r2`, `r3` — регистры, `flag` — условные флаги (Zero, Sign, Carry, Overflow — совпадает с x86). `pc` — тоже какой-то регистр, но, видимо, чем-то необычный.

Попробуем нажать кнопку "Run":

![](writeup/prompt.png)

В регистрах изменились значения, а в оперативной памяти/программе жёлтый курсор переставился на адрес `0x06`. Тот же адрес записан в `pc`, и если `pc` поменять, то и позиция курсора изменится. Вероятно, это [program counter](https://en.wikipedia.org/wiki/Program_counter), альтернативное название instruction pointer.

В консоли можно ввести пароль. Независимо от введённых символов ровно через 8 нажатий выводится строка «Forbidden.», а программа останавливается:

![](writeup/halted.png)

При этом в памяти что-то меняется, так что она всё же является RAM, а не ROM. «Run» больше не работает, но после перезагрузки страницы всё восстанавливается в изначальное состояние.

В исходниках веб-страницы ничего интересного, там только общение с сервером, поэтому, вероятно, придётся честно распознавать архитектуру. Поскольку супер-компьютер разработан в УНИИИУ, а опкоды не похожи ни на arm, ни на x86, да и регистра всего четыре, скорее всего, архитектура это какая-то своя, и как она работает — придётся узнавать руками.


## Опкоды

Действие инструкций исследуют, запуская их с разными входными данными и анализируя, что при этом происходит с регистрами и памятью.

Очистим всю память и начнём с опкода `00`. «Step» её исполняет и останавливается на адресе `01`, т.е. это однобайтовая инструкция. Положим в регистры случайные значения, установим случайные флаги, запустим опять — ничего не происходит. Вероятно, это `nop`, как раз похоже на опкод `00`.

Опкод `01`, судя по всему, копирует значение из `r0` в `r1`. `02` — из `r0` в `r2`, `03` — вы угадали, из `r0` в `r3`. По аналогии, видимо, `00` — это `mov` из `r0` в `r0`.

`04` — это `mov r0, r1`. `05` тоже ничего не делает, `06` — `mov r2, r1`, `07` — `mov r3, r1`. Похоже на то, что младшие два бита означают источник, а следующие два бита — назначение `mov`. Проверим, действительно ли `0e` копирует из `r4` в `r3`? Да, это так. Мы декодировали один опкод! Запишем:

```
0000ssdd mov d, s
```

Попробуем теперь следующий неопознанный опкод, `10`. Запустим его со значениями регистров `r0 = 11, r1 = 22, r2 = 33, r3 = 44`. В `r0` оказался `22`. Странно, опять `mov`, что ли? Или закономерности между регистрами проявились? Поставим случайные значения регистров: из `48 81 0c 54` стало `90`. О, это же `48 * 2` в шестнадцатеричке! Запишем: `10` умножает `r0` на `2`.

Попробуем `11`: `48 81 0c 54 -> 48 c9 0c 54`. Это не похоже на умножение, но `c9` — это в точности `48 + 81`. `11` — это `add r1, r0`. А `10` — это тогда `add r0, r0`. Хмм... Проанализируем закономерность на `12`, `13`, `14` — видимо, это действительно бинарная операция `add`. Удостоверимся, что `1e`, `1f` тоже работают как надо, и запишем:

```
0001ssdd add d, s
```

Судя по всему, у бинарных операций здесь более-менее одинаковый формат: первые 4 бита задают операцию, затем идут номера регистров-аргументов. `20` записало в `r0` нуль, `21`: `48 81 0c 54 -> 48 c9 0c 54`. Опять сумма, что ли? Попробуем другие аргументы: `0c 54 00 00 -> 0c 58 00 00`. Как получить `58` из `54` и `0c`? Не OR, не AND, ага, XOR! Проверяем парочку других комбинаций и записываем:

```
0010ssdd xor d, s
```

После этого аналогичными методами восстанавливается:

```
0011ssdd and d, s
```

Вот с `40` уже туго. После этой операции в `r0` оказывается нуль. `41` зануляет `r1`, `42` — `r2`, `43` — `r3`, и вроде бы и ладно, но `44`, `48` и `4c` *тоже* зануляют `r0`, и откуда такие дубликаты — непонятно. Действительно, что ли, биты игнорируются? Почему тогда в загруженной по умолчанию программе, где третья инструкция — `42`, в `r2` оказывается не `00`, а `45`? На нашей "пустой" машине инструкция загружает нуль даже с теми же регистрами, в чём же разница? Хмм.. а может, эта инструкция работает с памятью? Если считать, что инструкция `42` — это всё же `?? d, s`, и `s` не игнорируется, то в качестве `s` выступал бы `r0`. В `r0` записано `a9`, а по адресу `a9` как раз лежит `45`. Да, это чтение из памяти!

```
0100ssdd ldr d, s
```

Наученные горьким опытом, запустим с регистрами `11 22 33 44` опкод `50` и увидим, что по адресу `11` записалось `11`. Поэкспериментируем еще немного и подтвердим, что это инструкция записи в память.

```
0101ssdd str d, s
```

Инструкция `60` при запуске на `11 22 33 44` влияет на флаги, устанавливая флаг `Z`. Запуская её с разными входными значениями флагов, можно понять, что она всегда ставит флаги `Zsco`, а не просто поднимает `Z`. Поскольку до этого момента ни одна инструкция на флаги не влияла, вероятно, `60` — либо операция загрузки флагов из обычного регистра (что опровергается запуском со всеми нулевыми регистрами), либо устанавливает фиксированные флаги, что больше похоже на правду.

`61` на регистрах `11 22 33 44` сбрасывает все флаги, но на `44 33 22 11` ставит `zSCo`. Можно проверить, что `r2` и `r3` ни на что не влияют, а `r0` и `r1` — да. Значит, это бинарная операция сравнения — либо `cmp`, либо `test` (из x86). Можно проверить, что если `r0 == r1`, флаги ставятся в `Zsco` независимо от конкретного значения, так что это всё же `cmp`, т.е. флаги ставятся согласно разности `d` и `s`:

```
0110ssdd cmp d, s
```

Следующая инструкция восстанавливается как:

```
0111ssdd or d, s
```

А вот с опкодом `80` начинается ерунда, потому что инструкция начинает занимать 2 байта. К счастью, такой опкод есть в самом начале дефолтной программы, и там `80 a9` загружает в регистр `r0` значение `a9`, а затем `81 b9` загружает в `r1` значение `b9`. Поиграемся и сойдёмся на том, что эта инструкция загрузки константы в регистр:

```
100000dd iiiiiiii imm d, i
```

Инструкция `84` занимает один байт и превращает `r0 = 11` в `r0 = ef`, а при втором запуске — обратно. Вероятно, это отрицание. Опять перебираем `85`, `86`, `87`:

```
100001dd neg d
```

`88` превращает `r0 = 11` в `r0 = ee`. Это уже похоже просто на инверсию. Опять проверяем, опять удостоверяемся:

```
100010dd com d
```

Уже понятно, что в карте опкодов, вероятно, закончилось место для нормальных двухаргументных инструкций, и сейчас пойдут унарные и инструкции с нестандартным форматом.

`8c` превращает `11 22 33 44` в `22 33 44 44`, а `48 81 0c 54` в `90 81 0c 54`. Опять выглядит как умножение `r0` на 2. `8d`, `8e`, `8f` делают то же самое с `r1`, `r2`, `r3` соответственно. Странно, что есть инструкция-дубликат, но опустим это.

```
100011dd shl d, 1
```

Инструкция `90` при запуске переводит программу в состояние «Waiting for serial input». При вводе символа в `r0` оказывается код введённого символа. Проверяем ещё три опкода и пишем:

```
100100dd in d
```

Аналогично, `94` занимается выводом:

```
100101ss out s
```

Инструкция `98` как будто бы ничего не делает, но `99` устанавливает флаги `zSco` на `48 81 0c 54`. Хм, может и `98` тогда влияет на флаги? Да, она их сбрасывает. На входе `11 22 33 44` оба опкода сбрасывают флаги. Экспериментируем и понимаем, что эта унарная операция, просто выставляющая флаги Z и S в соответствии с регистром, т.е. инструкция `tst`:

```
100110ss tst s
```

`9c` игнорирует `r1`, `r2`, `r3` и переводит `r0` из `11` в `88`, а из `88` в `11`. Что это за такая хитрая унарная операция? `00 <-> 00`, `01 <-> 80`, `02 <-> 40`, `03 <-> c0`... О, это же переворот битов!

```
100111dd rbt d
```

`a0` двухаргументная. `a0 00` будто ничего не делает, `a0 01` переводит `r0` из `11` в `08`, из `44` в `22`. Звучит как сдвиг вправо на `1`. `a0 03` переводит `ff` в `1f`, т.е. второй аргумент — это величина сдвига:

```
101000dd shr d, i
```

`a4` — также сдвиг. Почему есть два сдвига? Заметим, что `ff` всё же переводится в `ff`, т.е. это, скорее всего, знаковый сдвиг:

```
101001dd sar d, i
```

Следующие опкоды восстанавливаются как повороты:

```
101010dd rol d, i
101011dd ror d, i
```

С `b0` начинается веселье. Внезапно `pc` переключается на `00`. Это похоже на инструкцию прыжка, но почему `00`? Ах да, у этой инструкции, вероятно, есть второй байт: `b0 01` переставляет `pc` на `01`.

```
10110000 iiiiiiii jmp i
```

`b1 01` не делает ничего, как и все следующие инструкции вплоть до `b8 01`, а `b9 01`, `ba 01` и т.д. вплоть до `bf 01` опять совершают прыжок на `01`. Почему так много одинаковых инструкций прыжков? А, наверное, это условные прыжки, а у нас просто все флаги сброшены. Здесь можно написать скрипт, запускающий эти инструкции с разными флагами и анализирующий, при каких комбинациях прыжок происходит. Загуглив, как инструкции условных прыжков обычно зависят от флагов, можно восстановить, что условия соответствуют следующей логике:

```
10110000 iiiiiiii jmp i
10110001 iiiiiiii jl i
10110010 iiiiiiii jbe i
10110011 iiiiiiii jle i
10110100 iiiiiiii je i
10110101 iiiiiiii js i
10110110 iiiiiiii jb i
10110111 iiiiiiii jo i
10111000 iiiiiiii nop
10111001 iiiiiiii jge i
10111010 iiiiiiii ja i
10111011 iiiiiiii jg i
10111100 iiiiiiii jne i
10111101 iiiiiiii jns i
10111110 iiiiiiii jae i
10111111 iiiiiiii jno i
```

`nop` на `10111000` — это, вероятно, артефакт результата обращения условия безусловного `jmp`, и на самом деле это инструкция "прыгать никогда".

`c0` инкрементирует `r0`, `c4` декрементирует:

```
110000dd inc d
110001dd dec d
```

`c8` и все инструкции дальше вплоть до `ff` выводят ошибку «Undefined instruction», а `ff` выводит «Halted»:

```
11111111 hlt
```

Есть некоторая вероятность, что на самом деле какие-то опкоды там есть, просто они двухбайтные, но учитывая то, что байтов выше `c8` в программе очень мало, вероятно, это просто данные, а инструкций там действительно нет. Поздравляю, вы дошли до конца internet!


## Опкоды — методом пристального взгляда

Вариант разбора от участников. Мнемоники не совпадают с официальными из-за [clean-room](https://en.wikipedia.org/wiki/Clean-room_design) решения.

Альтернативный метод получения опкодов — нажимать на "Step" и смотреть за поведением. Эта кнопка просит выполнять инструкции по одной, что позволяет увидеть размер всех инструкций, циклы, а также влияние инструкций на регистры и память.

Таким образом, только на первом прогоне цикла можно заметить следующее:

```
00: 80 a9 # в r0 записалось 0xa9
02: 81 b9 # в r1 записалось 0xb9
04: 42    # в r2 загрузилось значение 0x45 ('E')
05: 96    # на экран вывелось E
06: c0    # значение r0 теперь 0xaa
07: 64    # обновился регистр флагов
08: bc 04 # переходит назад на позицию 4
```

На последующих прогонах цикла можно заметить, что инструкция `0xc0` всегда увеличивает `r0` на единицу, инструкция `0x42` постоянно загружает в `r2` новые символы пароля (ищем пароль в памяти, понимаем что символы загружаются с адреса из регистра `r0`), а цикл завершается, когда инструкция `0x64` устанавливает флаг `Z` (в этот момент `r0` становится равно `r1`, что заставляет предположить, что `0x64` сравнивает `r0` и `r1`).

По первым двум инструкциям можно предположить, что младшие 2 бита опкода кодируют регистр, с которым работает инструкция, и, соответственно, инструкции `0x82` и `0x83` будут загружать значения в регистры `r2` и `r3`. Вбиваем эти опкоды в память и убеждаемся, что это действительно так.

Теперь заметим, что в младших битах инструкций `0x42` и `0x96`, работающих с регистром `r2`, записано 2, а в младших битах инструкций `0xc0` и `0x64`, работающих с регистром `r0`, записано 0 — логично предположить, что эти инструкции тоже хранят свой операнд в младших битах. Проверяем, убеждаемся что это так. Но у инструкции `0x64` явно есть ещё один операнд (`r1`) — логично поискать его номер ещё где-то в битовой записи инструкции. Пристально вглядываемся и видим, что биты 2 и 3 числа `0x64` кодируют число 1. Проверяем, убеждаемся что это так.

Таким образом, получаем следующую частичную таблицу инструкций:

```
0100 00xx -> mov rX, [r0]
0110 yyxx -> cmp rX, rY
1000 00xx -> mov rX, [следующий байт]
1001 01xx -> put rX
1011 1100 -> jnz [следующий байт] (то есть, переходит по закодированному в инструкции адресу, если флаг ZF не взведён)
1100 00xx -> inc rX
```

С такими знаниями уже можно пытаться писать дизассемблер. Получаем примерно следующее:

```
00: mov r0, 0xa9
02: mov r1, 0xb9
04: mov r2, [r0]
05: put r2
06: inc r0
07: cmp r0, r1
08: jnz 0x4
...до сюда мы уже разобрали код. Посмотрим, насколько понятным станет дальнейший мусор...
0a: mov r0, 0xb1
0c: 0x92 # неизвестный опкод
0d: 0x58 # неизвестный опкод
0e: inc r0
0f: cmp r0, r1
10: jnz 0xc
```

Как видим, вполне читаемо. Пройдём ещё раз по коду пошаговой отладкой, и поймём, что `0x92` — это чтение из консоли в регистр `r2` (аналогично `0x96` предполагаем что регистр назначения кодируется младшими битами), а `0x58` — это команда, записывающая `r2` в память... и мы видим, что регистр `r2` закодирован не в привычной нижней позиции, а в позиции второго операнда. Это заставляет предположить, что позиция первого операнда кодирует регистр `r0`, относительно которого происходит запись. Проверяем, убеждаемся что это так. На этом моменте логично предположить, что то же самое справедливо и для инструкции чтения памяти, с точностью до порядка операндов — и да, это тоже оказывается так. Получаем такую таблицу инструкций:

```
0100 yyxx -> mov rX, [rY]
0101 yyxx -> mov [rX], rY
0110 yyxx -> cmp rX, rY
1000 00xx -> mov rX, [следующий байт]
1001 00xx -> get rX
1001 01xx -> put rX
1011 1100 -> jnz [следующий байт]
1100 00xx -> inc rX
```

Идём дальше по коду:

```
12: mov r0, 0x0a # '\n'
14: put r0  # выводит в консоль перевод строки
15: mov r0, 0xa9
17: 0xc5  # r1 принимает значение b8, было b9
18: mov r2, [r1]
19: mov [r0], r2
1a: inc r0
1b: cmp r0, r1
1c: jnz 0x17
```

Сделаем единственно логичное предположение: опкоды `0xc4-0xc7` кодируют инструкцию декремента. После этого видим выглядящий довольно логично цикл переворачивания массива в памяти. Это говорит о том, что, скорее всего, мы на верном пути. Продолжаем дизассемблировать.

```
1e: dec r1
1f: mov r0, [r1]
20: 0x84
21: dec r1
22: mov r2, [r1]
23: dec r2
24: dec r1
25: mov r3, [r1]
26: 0xab 0x5  # то, что это цельная инструкция, можно понять пошаговой отладкой
28: 0x13
29: mov [r1], r3
2a: dec r1
2b: dec r1
2c: mov r0, [r1]
2d: 0x88
2e: 0x2c
2f: mov [r1], r0
30: dec r1
31: dec r1
32: mov r3, [r1]
33: 0xaf
34: 0x2
35: 0x1b
36: mov [r1], r3
37: dec r1
38: mov r2, [r1]
39: 0x9e
3a: 0x22
3b: mov [r1], r2
3c: inc r1
3d: mov r0, [r1]
3e: inc r1
3f: mov r3, [r1]
40: 0xab 0x7
42: 0x2b
```

Здесь мы наконец видим инструкции, производящие, судя по монитору, какие-то арифметические операции. На этом этапе исследовать поведение инструкций внутри кода уже неудобно, поэтому перезапустим виртуалку и запишем в память следующее:

```
0: [интересующий нас опкод]
1: jnz 0
```

Поскольку мы пока не нашли инструкцию безусловного перехода, приходится пользоваться условным. Это не проблема, поскольку большинство инструкций на этом процессоре не трогают флаги, а исходно ZF сброшен. Видим следующее поведение:

- `0x84` — с исходными значениями регистров ничего не делает, но если записать в `r0` единицу, значение начинает скакать между `1` и `0xff` (`-1`). Делаем вывод, что это инструкция `neg` (унарный минус). По аналогии с инструкциями `inc` / `dec` понимаем, что `0x85-0x87` это `neg r1-r3` соответственно.
- `0xab 0x05` — так же ничего не делает на нулевых регистрах, но если угадать по младшим битам, что один из операндов — `r3`, и записать в `r3` единицу, то `r3` начинает в цикле пробегать значения `1`, `0x20`, `4`, `0x80`, `16`, `2`, `0x40`, `8`. По цикличности и сходству с битовым сдвигом в этой инструкции можно узнать инструкцию поворота битов влево на 5 позиций. Напрашивается очевидный вывод, что байт `0x05` — это дополнительный операнд, кодирующий размер поворота. Проверяем и убеждаемся что это так.
- `0x13` — так же ничего не делает при всех нулевых регистрах, запись единицы в `r3` тоже ничего не даёт. Но если записать единицу в `r0`, инструкция начинает вести себя как `inc r3`. Напрашивается логичный вывод, что эта инструкция — `add r3, r0`. По аналогии с `cmp` понимаем вероятное значение остальных опкодов `0x10-0x1f`.
- `0x88` — регистр `r0` чередует значения `0` и `0xff`. Так ведёт себя операция побитового НЕ (`not`). По аналогии с `neg` угадываем опкоды `0x89-0x8b`.
- `0x9e` — при записи единицы в `r2`, `r2` начинает циклически переходить между состояниями `1` и `0x80`. Похоже на операцию переворота битовой записи числа (для определённости обозначим её `rev`).
- `0x22` — при записи единицы в `r0`, `r2` начинает переключаться между состояниями `0` и `1`. Так ведёт себя побитовое исключающее ИЛИ (`xor`).
- `0xab 0x07` — уже известная нам инструкция `rol`, но с другим операндом.
- `0x2b` — уже известная нам инструкция `xor`, но с другими операндами.

Получаем такую таблицу инструкций:

```
0001 yyxx -> add rX, rY
0010 yyxx -> xor rX, rY
0100 yyxx -> mov rX, [rY]
0101 yyxx -> mov [rX], rY
0110 yyxx -> cmp rX, rY
1000 00xx -> mov rX, [следующий байт]
1000 01xx -> neg rX
1000 10xx -> not rX
1001 00xx -> get rX
1001 01xx -> put rX
1001 11xx -> rev rX
1010 10xx -> rol rX, [следующий байт]
1011 1100 -> jnz [следующий байт]
1100 00xx -> inc rX
1100 01xx -> dec rX
```

С такой таблицей почти весь код декодируется. Остаётся всего несколько неизвестных опкодов:

```
33: 0xaf 0x02
60: 0x9a # устанавливает флаги
84: 0x9b # устанавливает флаги
9f: 0xb0 0xf9
```

- `0xaf 0x02` — ведёт себя аналогично `rol`, но значения пробегаются в обратном порядке. Это `ror` (поворот битов вправо).
- `0x9a` (`0x9b`) — устанавливают флаг ZF, если число в регистре `r2` (`r3`) равно нулю, и SF, если в нём установлен старший бит. Это соответствует поведению инструкции [`test`](https://www.felixcloutier.com/x86/test) из x86.
- `0xb0 0xf9` — переходит на адрес `0xf9`. Попереключаем флаги и убеждаемся, что переход происходит всегда, то есть является безусловным. Поскольку переходов на адрес `0xa1` в коде нигде не видно, делаем вывод, что осмысленный код на этом месте заканчивается, и дальше можно сразу смотреть код по адресу `0xf9`.

```
f7: put r0
f8: inc r3
f9: mov r0, [r3]
fa: tst r0
fb: jnz 0xf7
fd: mov r1, 0xff
ff: mov [r0], r1
```

Мы видим, что этот код выводит строку из памяти, после чего записывает по адресу 0 (оставшемуся в регистре `r0`) байт `0xff` и даёт счётчику команд переполниться. Можно догадаться, что `0xff` — это инструкция [завершения работы программы](https://en.wikipedia.org/wiki/HLT_(x86_instruction)). Это единственное место в программе, где используется самомодифицирующийся код.

Самомодифицирующийся код — изюминка задачи, чтобы участники не пошли запускать использованную прошивку по второму кругу.


## Декомпиляция

Теперь, когда мы знаем набор инструкций, можно посмотреть на то, что, собственно, представляет из себя программа.

Запустив её, мы видим, что она спрашивает пароль, считывает ровно 8 символов, после чего печатает "Forbidden". В контексте CTF такое поведение обычно означает, что программа проверяет каким-то образом пароль на корректность, после чего использует его как ключ для расшифровки флага.

Соответственно, чтобы получить флаг, нам нужно узнать этот самый пароль. Поскольку читать сырой ассемблер — занятие для мазохистов, хочется увидеть какую-то более приличную декомпиляцию кода.

"Каноничным" "правильным" "industry standard" решением было бы написать плагин для IDA Pro/Ghidra с поддержкой нашей кастомной архитектуры, но разбираться с написанием плагинов к промышленному софту в авральном режиме во время CTF — сомнительная идея, поэтому нам нужен способ проще.

Логичная идея, которая приходит в голову — написать эмулятор этого процессора, но таким образом, чтобы при компиляции его с оптимизациями логика эмуляции везде заинлайнилась, и в бинарнике остался только нативный код, функционально эквивалентный исходному машинному коду для неизвестного процессора.

Такой "эмулятор" (наверное, правильнее было бы назвать это "статический транслятор времени компиляции") можно [элегантно реализовать на C++](./contrib/emulator.cpp), используя механизм шаблонов. Идея в следующем: функция

```cpp
template<int pc> void emulate(uint8_t r0, ..., uint8_t r3, bool z)
```

принимает на вход текущее состояние регистров общего назначения, реализует над регистрами инструкцию по текущему `pc`, и вызывает хвостовым вызовом аналогичную функцию `emulate<следующий pc>` с новым состоянием регистров (стандарт C++ не гарантирует tail call optimization, но в `clang` есть атрибут `musttail`, который заставляет его её использовать). Чтобы это корректно реализовать, нам нужно следующее:

1. Во-первых, придётся забыть про самомодифицирующийся код. В данной нам программе он используется только для красивого завершения, что нам в принципе не очень принципиально, поэтому заведём два отдельных массива: `static constexpr uint8_t code[256] = {...};` для кода, и `uint8_t data[256] = {...};` для данных. Исходно они, естественно, всё ещё заполняются одинаковыми значениями.
2. Во-вторых, парсинг инструкции (до состояния «операция такая-то, операнды такие-то и такие-то») нужно производить полностью во время компиляции. Для создания вспомогательных переменных времени компиляции можно использовать конструкцию вида `enum { переменная = выражение };`. Так как каждый enum — это отдельный тип, все его значения компилятор обязан вычислить при компиляции.
3. Значительная часть парсинга инструкций — это последовательность `if...else`, проверяющая разные известные опкоды. Чтобы компилятор выбрал во время компиляции конкретную ветку этого `if...else`, вместо обычного `if` нужно использовать конструкцию `if constexpr` из C++17. Если этого не сделать, то на этапе оптимизации компилятор всё равно выкинет лишний код, но перед этим могут быть проинстанцированы шаблонные функции `emulate<pc>` для адресов, на которые управление по факту перейти не может, что не есть хорошо.
4. Для получения доступа к регистрам по номеру можно воспользоваться массивом, но на маленьких уровнях оптимизации программа будет тратить время на создание массива и доступ по индексу. Чтобы гарантированно выбрать нужную переменную именно во время компиляции, можно объявить функцию
    ```cpp
    template<int which_reg> uint8_t& reg(uint8_t& r0, ..., uint8_t& r3)
    ```
    прописать ей атрибут `always_inline`, а внутри через `if constexpr` выбрать и вернуть правильный аргумент. Тогда даже на нулевом уровне оптимизации компилятор соптимизирует это до простого обращения к заранее известной переменной.

В качестве дополнительной сомнительной оптимизации можно было бы сделать шаблонным параметром не только `pc`, но и флаги. Для такой простой архитектуры как здесь это не имеет смысла, так как компилятор и так смержит расчёт флагов с последующей проверкой, но для архитектуры с более "весёлым" расчётом флагов (`x86` / `ARM`, я смотрю на вас) такая оптимизация может оказаться существенной.

Теперь этот "эмулятор" можно скомпилировать с оптимизациями командой

```shell
$ clang++ -gdwarf-4 -O3 emulator.cpp -o emulator
```

и загнать в гидру.

В самом начале программа выводит строку `"Enter password: "` и считывает 8 символов пароля, а затем кладёт отзеркаленно их рядом:

![](./writeup/rev.png)

Будем аккуратно "резать" `data` на переменные с понятными названиями. Пароль, который мы ввели лежит в `pass_second`, отзеркаленная копия лежит в `pass_first`.

В самом конце программа выводит или NUL-терминированную строку `"Forbidden"` или флаг, тоже NUL-терминированный. Назовём побольше переменных.

![](./writeup/rev2.png)

Цикл перед этим местом расшифровывает флаг, а ещё раньше перед ним есть какой-то цикл, который выполняется 4 раза:

![](./writeup/rev3.png)

Этот цикл делает какие-то манипуляции над `pass_first`.

Между циклами есть какая-то очень страшно декомпилировавшаяся проверка на совпадение двух восьмибайтовых последовательностей — и проверка ведётся именно с `pass_first`, причём в случае совпадения `pass_first` с `correct` мы идём расшифровывать флаг:

![](./writeup/rev4.png)

Посмотрим, какие преобразования выполняются над `pass_first = pass_second[::-1]`, чтобы получить `correct = [b1 da c5 d5 9c 50 26 2c]`.

![](./writeup/rev5.png)

Пусть `[A, B, C, D, E, F, G, H]` это `pass_first[0..8] = pass_second[0..8][::-1]`, тогда цикл будет выглядеть так:

```c
for (int _ = 0; _ < 4; ++_) {
    F = (F << 5 | (byte)F >> 3) - H;
    cVar3 = (B << 6 | (byte)B >> 2) + G;
    B = cVar3 - 1;  // (1)
    bVar1 = A << 4 | (byte)A >> 4;
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    A = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ ~(D ^ F);
    C = ((byte)C >> 1 | C << 7) ^ A;
    bVar1 = E << 4 | E >> 4;
    D = cVar3 + ~(D ^ F);
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    E = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ B;
    G = (F - G) - 2;
    H = H ^ C;
    count = count + -1;
}
```

Схлопнем локальные переменные: `cVar3` после подстановки в `(1)` выражается как `B + 1`.

```c
for (int _ = 0; _ < 4; ++_) {
    F = (F << 5 | (byte)F >> 3) - H;
    B = (B << 6 | (byte)B >> 2) + G - 1;
    bVar1 = A << 4 | (byte)A >> 4;
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    A = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ ~(D ^ F);
    C = ((byte)C >> 1 | C << 7) ^ A;
    bVar1 = E << 4 | E >> 4;
    D = B + 1 + ~(D ^ F);
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    E = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ B;
    G = (F - G) - 2;
    H = H ^ C;
}
```

Теперь осталась только странная `bVar1`. Посмотрим поближе на места использования и заменим `* '\x02'` на более понятное `<< 1`:

```c
// Exhibit 1
bVar1 = A << 4 | (byte)A >> 4;
bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
A = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) << 1) ...;

// Exhibit 2
bVar1 = E << 4 | E >> 4;
bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
E = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) << 1) ...;
```

В первом случае `bVar1` используется, чтобы записать `op(A)`, а во втором — `op(E)`, где `op(..)` — это странная операция. Обращаемся за помощью к исходникам эмулятора и на 95-й строке видим тот же код. Сверяемся по дизассемблеру — и получаем, что `op = rotate_bits`. Перепишем цикл ещё раз, учтя это (и то, что `A << (8-P) | (byte)A >> P` это `rotate_right(A, P)`):

```c
for (int _ = 0; _ < 4; ++_) {
    F = rotate_right(F, 3) - H;
    B = rotate_right(B, 2) + G - 1;
    A = rotate_bits(A) ^ ~(D ^ F);
    C = rotate_right(C, 1) ^ A;
    D = B + 1 + ~(D ^ F);
    E = rotate_bits(E) ^ B;
    G = F - G - 2;
    H = H ^ C;
}
```

Вынесем `~(D ^ F)` отдельно в переменную `D`, потому что она будет перетёрта последней и заменим `~x` на `x ^ 255`:

```c
for (int _ = 0; _ < 4; ++_) {
    F = rotate_right(F, 3) - H;
    D = D ^ F ^ 255;
    B = rotate_right(B, 2) + G - 1;
    A = rotate_bits(A) ^ D;
    C = rotate_right(C, 1) ^ A;
    D = B + 1 + D;
    E = rotate_bits(E) ^ B;
    G = F - G - 2;
    H = H ^ C;
}
```

Все действия здесь обратимы — воспользуемся [простым скриптом на Python](./extract_password.py) для того, чтобы вытащить пароль.

Пароль: [`2Re4l1Ty`](https://en.wikipedia.org/wiki/Second_Reality).

Вводим пароль в веб-интерфейс и получаем флаг:

![](./writeup/flag.png)

Флаг: **ugra_[commodore_64_basic_v2](https://www.c64-wiki.com/wiki/BASIC)\_[amiga_rulez](https://zxpress.ru/article.php?id=5467)_thml0wf0**

## Постмортем

`shl` — одноаргументная случайно, она должна была принимать immediate аргумент.
