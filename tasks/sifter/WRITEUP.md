# Просеиватель: Write-up

В задании дан доступ к какой-то машине:

![](writeup/start.png)

Большой квадрат — это, вероятно, оперативная память или код программы. `r0`, `r1`, `r2`, `r3` — регистры, `flag` — условные флаги (Zero, Sign, Carry, Overflow — совпадает с x86). `pc` — тоже какой-то регистр, но, видимо, чем-то необычный.

Попробуем нажать кнопку "Run":

![](writeup/prompt.png)

В регистрах изменились значения, а в оперативной памяти/программе жёлтый курсор переставился на адрес `0x06`. Тот же адрес записан в `pc`, и если `pc` поменять, то и позиция курсора изменится. Вероятно, это [program counter](https://en.wikipedia.org/wiki/Program_counter), альтернативное название instruction pointer.

В консоли можно ввести пароль. Независимо от введённых символов ровно через 8 нажатий выводится строка «Forbidden.», а программа останавливается:

![](writeup/halted.png)

При этом в памяти что-то меняется, так что она всё же является RAM, а не ROM. «Run» больше не работает, но после перезагрузки страницы всё восстанавливается в изначальное состояние.

В исходниках веб-страницы ничего интересного, там только общение с сервером, поэтому, вероятно, придётся честно распознавать архитектуру. Поскольку супер-компьютер разработан в УНИИИУ, а опкоды не похожи ни на arm, ни на x86, да и регистра всего четыре, скорее всего, архитектура это какая-то своя, и как она работает — придётся узнавать руками.


## Опкоды

Действие инструкций исследуют, запуская их с разными входными данными и анализируя, что при этом происходит с регистрами и памятью.

Очистим всю память и начнём с опкода `00`. «Step» её исполняет и останавливается на адресе `01`, т.е. это однобайтовая инструкция. Положим в регистры случайные значения, установим случайные флаги, запустим опять — ничего не происходит. Вероятно, это `nop`, как раз похоже на опкод `00`.

Опкод `01`, судя по всему, копирует значение из `r0` в `r1`. `02` — из `r0` в `r2`, `03` — вы угадали, из `r0` в `r3`. По аналогии, видимо, `00` — это `mov` из `r0` в `r0`.

`04` — это `mov r0, r1`. `05` тоже ничего не делает, `06` — `mov r2, r1`, `07` — `mov r3, r1`. Похоже на то, что младшие два бита означают источник, а следующие два бита — назначение `mov`. Проверим, действительно ли `0e` копирует из `r4` в `r3`? Да, это так. Мы декодировали один опкод! Запишем:

```
0000ssdd mov d, s
```

Попробуем теперь следующий неопознанный опкод, `10`. Запустим его со значениями регистров `r0 = 11, r1 = 22, r2 = 33, r3 = 44`. В `r0` оказался `22`. Странно, опять `mov`, что ли? Или закономерности между регистрами проявились? Поставим случайные значения регистров: из `48 81 0c 54` стало `90`. О, это же `48 * 2` в шестнадцатеричке! Запишем: `10` умножает `r0` на `2`.

Попробуем `11`: `48 81 0c 54 -> 48 c9 0c 54`. Это не похоже на умножение, но `c9` — это в точности `48 + 81`. `11` — это `add r1, r0`. А `10` — это тогда `add r0, r0`. Хмм... Проанализируем закономерность на `12`, `13`, `14` — видимо, это действительно бинарная операция `add`. Удостоверимся, что `1e`, `1f` тоже работают как надо, и запишем:

```
0001ssdd add d, s
```

Судя по всему, у бинарных операций здесь более-менее одинаковый формат: первые 4 бита задают операцию, затем идут номера регистров-аргументов. `20` записало в `r0` нуль, `21`: `48 81 0c 54 -> 48 c9 0c 54`. Опять сумма, что ли? Попробуем другие аргументы: `0c 54 00 00 -> 0c 58 00 00`. Как получить `58` из `54` и `0c`? Не OR, не AND, ага, XOR! Проверяем парочку других комбинаций и записываем:

```
0010ssdd xor d, s
```

После этого аналогичными методами восстанавливается:

```
0011ssdd and d, s
```

Вот с `40` уже туго. После этой операции в `r0` оказывается нуль. `41` зануляет `r1`, `42` — `r2`, `43` — `r3`, и вроде бы и ладно, но `44`, `48` и `4c` *тоже* зануляют `r0`, и откуда такие дубликаты — непонятно. Действительно, что ли, биты игнорируются? Почему тогда в загруженной по умолчанию программе, где третья инструкция — `42`, в `r2` оказывается не `00`, а `45`? На нашей "пустой" машине инструкция загружает нуль даже с теми же регистрами, в чём же разница? Хмм.. а может, эта инструкция работает с памятью? Если считать, что инструкция `42` — это всё же `?? d, s`, и `s` не игнорируется, то в качестве `s` выступал бы `r0`. В `r0` записано `a9`, а по адресу `a9` как раз лежит `45`. Да, это чтение из памяти!

```
0100ssdd ldr d, s
```

Наученные горьким опытом, запустим с регистрами `11 22 33 44` опкод `50` и увидим, что по адресу `11` записалось `11`. Поэкспериментируем еще немного и подтвердим, что это инструкция записи в память.

```
0101ssdd str d, s
```

Инструкция `60` при запуске на `11 22 33 44` влияет на флаги, устанавливая флаг `Z`. Запуская её с разными входными значениями флагов, можно понять, что она всегда ставит флаги `Zsco`, а не просто поднимает `Z`. Поскольку до этого момента ни одна инструкция на флаги не влияла, вероятно, `60` — либо операция загрузки флагов из обычного регистра (что опровергается запуском со всеми нулевыми регистрами), либо устанавливает фиксированные флаги, что больше похоже на правду.

`61` на регистрах `11 22 33 44` сбрасывает все флаги, но на `44 33 22 11` ставит `zSCo`. Можно проверить, что `r2` и `r3` ни на что не влияют, а `r0` и `r1` — да. Значит, это бинарная операция сравнения — либо `cmp`, либо `test` (из x86). Можно проверить, что если `r0 == r1`, флаги ставятся в `Zsco` независимо от конкретного значения, так что это всё же `cmp`, т.е. флаги ставятся согласно разности `d` и `s`:

```
0110ssdd cmp d, s
```

Следующая инструкция восстанавливается как:

```
0111ssdd or d, s
```

А вот с опкодом `80` начинается ерунда, потому что инструкция начинает занимать 2 байта. К счастью, такой опкод есть в самом начале дефолтной программы, и там `80 a9` загружает в регистр `r0` значение `a9`, а затем `81 b9` загружает в `r1` значение `b9`. Поиграемся и сойдёмся на том, что эта инструкция загрузки константы в регистр:

```
100000dd iiiiiiii imm d, i
```

Инструкция `84` занимает один байт и превращает `r0 = 11` в `r0 = ef`, а при втором запуске — обратно. Вероятно, это отрицание. Опять перебираем `85`, `86`, `87`:

```
100001dd neg d
```

`88` превращает `r0 = 11` в `r0 = ee`. Это уже похоже просто на инверсию. Опять проверяем, опять удостоверяемся:

```
100010dd com d
```

Уже понятно, что в карте опкодов, вероятно, закончилось место для нормальных двухаргументных инструкций, и сейчас пойдут унарные и инструкции с нестандартным форматом.

`8c` превращает `11 22 33 44` в `22 33 44 44`, а `48 81 0c 54` в `90 81 0c 54`. Опять выглядит как умножение `r0` на 2. `8d`, `8e`, `8f` делают то же самое с `r1`, `r2`, `r3` соответственно. Странно, что есть инструкция-дубликат, но опустим это.

```
100011dd shl d, 1
```

Инструкция `90` при запуске переводит программу в состояние «Waiting for serial input». При вводе символа в `r0` оказывается код введённого символа. Проверяем ещё три опкода и пишем:

```
100100dd in d
```

Аналогично, `94` занимается выводом:

```
100101ss out s
```

Инструкция `98` как будто бы ничего не делает, но `99` устанавливает флаги `zSco` на `48 81 0c 54`. Хм, может и `98` тогда влияет на флаги? Да, она их сбрасывает. На входе `11 22 33 44` оба опкода сбрасывают флаги. Экспериментируем и понимаем, что эта унарная операция, просто выставляющая флаги Z и S в соответствии с регистром, т.е. инструкция `tst`:

```
100110ss tst s
```

`9c` игнорирует `r1`, `r2`, `r3` и переводит `r0` из `11` в `88`, а из `88` в `11`. Что это за такая хитрая унарная операция? `00 <-> 00`, `01 <-> 80`, `02 <-> 40`, `03 <-> c0`... О, это же переворот битов!

```
100111dd rbt d
```

`a0` двухаргументная. `a0 00` будто ничего не делает, `a0 01` переводит `r0` из `11` в `08`, из `44` в `22`. Звучит как сдвиг вправо на `1`. `a0 03` переводит `ff` в `1f`, т.е. второй аргумент — это величина сдвига:

```
101000dd shr d, i
```

`a4` — также сдвиг. Почему есть два сдвига? Заметим, что `ff` всё же переводится в `ff`, т.е. это, скорее всего, знаковый сдвиг:

```
101001dd sar d, i
```

Следующие опкоды восстанавливаются как повороты:

```
101010dd rol d, i
101011dd ror d, i
```

С `b0` начинается веселье. Внезапно `pc` переключается на `00`. Это похоже на инструкцию прыжка, но почему `00`? Ах да, у этой инструкции, вероятно, есть второй байт: `b0 01` переставляет `pc` на `01`.

```
10110000 iiiiiiii jmp i
```

`b1 01` не делает ничего, как и все следующие инструкции вплоть до `b8 01`, а `b9 01`, `ba 01` и т.д. вплоть до `bf 01` опять совершают прыжок на `01`. Почему так много одинаковых инструкций прыжков? А, наверное, это условные прыжки, а у нас просто все флаги сброшены. Здесь можно написать скрипт, запускающий эти инструкции с разными флагами и анализирующий, при каких комбинациях прыжок происходит. Загуглив, как инструкции условных прыжков обычно зависят от флагов, можно восстановить, что условия соответствуют следующей логике:

```
10110000 iiiiiiii jmp i
10110001 iiiiiiii jl i
10110010 iiiiiiii jbe i
10110011 iiiiiiii jle i
10110100 iiiiiiii je i
10110101 iiiiiiii js i
10110110 iiiiiiii jb i
10110111 iiiiiiii jo i
10111000 iiiiiiii nop
10111001 iiiiiiii jge i
10111010 iiiiiiii ja i
10111011 iiiiiiii jg i
10111100 iiiiiiii jne i
10111101 iiiiiiii jns i
10111110 iiiiiiii jae i
10111111 iiiiiiii jno i
```

`nop` на `10111000` — это, вероятно, артефакт результата обращения условия безусловного `jmp`, и на самом деле это инструкция "прыгать никогда".

`c0` инкрементирует `r0`, `c4` декрементирует:

```
110000dd inc d
110001dd dec d
```

`c8` и все инструкции дальше вплоть до `ff` выводят ошибку «Undefined instruction», а `ff` выводит «Halted»:

```
11111111 hlt
```

Есть некоторая вероятность, что на самом деле какие-то опкоды там есть, просто они двухбайтные, но учитывая то, что байтов выше `c8` в программе очень мало, вероятно, это просто данные, а инструкций там действительно нет. Поздравляю, вы дошли до конца internet!


## Декомпиляция

Зная, какая у этого процессора ISA, можно написать [простенький дизассемблер](./contrib/disasm.py) и посмотреть на [результат дизассемблирования](./contrib/disasm.s). Страшно, особенно в сравнении с [оригинальным](./prog.asm) асм-кодом с комментариями и отступами.

Вместо того, чтобы закапываться в этот ассемблер, можно сделать финт ушами — написать свой [«оптимизирующий» «эмулятор»](./contrib/emulator.cpp). Прелесть магии `constexpr`-ов в том, что эмулятор «эмулирует» ISA только в compile-time, и роль оптимизатора/AOT выполняет обычный компилятор C++. Компилируем эмулятор с помощью `clang++ -gdwarf-4 -O3 emulator.cpp -o emulator` и идём исследовать в Ghidra.

В самом начале программа выводит строку `"Enter password: "` и считывает 8 символов пароля, а затем кладёт отзеркаленно их рядом:

![](./writeup/rev.png)

Пароль, который мы ввели лежит в `pass_second`, отзеркаленная копия лежит в `pass_first`.

В конце программа выводит или NUL-терминированную строку `"Forbidden"` или флаг, тоже NUL-терминированный. Назовём побольше переменных.

![](./writeup/rev2.png)

Цикл перед этим местом расшифровывает флаг, а ещё раньше перед ним есть какой-то цикл, который выполняется 4 раза:

![](./writeup/rev3.png)

Этот цикл делает какие-то манипуляции над `pass_first`.

![](./writeup/rev4.png)

Между циклами есть какая-то очень страшно декомпилировавшаяся проверка на совпадение двух восьмибайтовых последовательностей — и проверка ведётся именно с `pass_first`, причём в случае совпадения `pass_first` с `correct` мы идём расшифровывать флаг.

![](./writeup/rev5.png)

Посмотрим, какие преобразования выполняются над `pass_first = pass_second[::-1]`, чтобы получить `correct = [b1 da c5 d5 9c 50 26 2c]`.

Пусть `[A, B, C, D, E, F, G, H]` это `pass_first[0..8] = pass_second[0..8][::-1]`, тогда цикл будет выглядеть так:

```c
for (int _ = 0; _ < 4; ++_) {
    F = (F << 5 | (byte)F >> 3) - H;
    cVar3 = (B << 6 | (byte)B >> 2) + G;
    B = cVar3 - 1;  // (1)
    bVar1 = A << 4 | (byte)A >> 4;
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    A = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ ~(D ^ F);
    C = ((byte)C >> 1 | C << 7) ^ A;
    bVar1 = E << 4 | E >> 4;
    D = cVar3 + ~(D ^ F);
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    E = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ B;
    G = (F - G) - 2;
    H = H ^ C;
    count = count + -1;
}
```

Схлопнем локальные переменные: `cVar3` после подстановки в `(1)` выражается как `B + 1`.

```c
for (int _ = 0; _ < 4; ++_) {
    F = (F << 5 | (byte)F >> 3) - H;
    B = (B << 6 | (byte)B >> 2) + G - 1;
    bVar1 = A << 4 | (byte)A >> 4;
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    A = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ ~(D ^ F);
    C = ((byte)C >> 1 | C << 7) ^ A;
    bVar1 = E << 4 | E >> 4;
    D = B + 1 + ~(D ^ F);
    bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
    E = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) * '\x02') ^ B;
    G = (F - G) - 2;
    H = H ^ C;
}
```

Теперь осталась только странная `bVar1`. Посмотрим поближе на места использования и заменим `* '\x02'` на более понятное `<< 1`:

```c
// Exhibit 1
bVar1 = A << 4 | (byte)A >> 4;
bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
A = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) << 1) ...;

// Exhibit 2
bVar1 = E << 4 | E >> 4;
bVar1 = bVar1 >> 2 & 0x33 | (bVar1 & 0x33) << 2;
E = (bVar1 >> 1 & 0x55 | (bVar1 & 0x55) << 1) ...;
```

В первом случае `bVar1` используется, чтобы записать `op(A)`, а во втором — `op(E)`, где `op(..)` — это странная операция. Обращаемся за помощью к исходникам эмулятора и на 95-й строке видим тот же код. Сверяемся по дизассемблеру — и получаем, что `op = rotate_bits`. Перепишем цикл ещё раз, учтя это (и то, что `A << (8-P) | (byte)A >> P` это `rotate_right(A, P)`):

```c
for (int _ = 0; _ < 4; ++_) {
    F = rotate_right(F, 3) - H;
    B = rotate_right(B, 2) + G - 1;
    A = rotate_bits(A) ^ ~(D ^ F);
    C = rotate_right(C, 1) ^ A;
    D = B + 1 + ~(D ^ F);
    E = rotate_bits(E) ^ B;
    G = F - G - 2;
    H = H ^ C;
}
```

Вынесем `~(D ^ F)` отдельно в переменную `D`, потому что она будет перетёрта последней и заменим `~x` на `x ^ 255`:

```c
for (int _ = 0; _ < 4; ++_) {
    F = rotate_right(F, 3) - H;
    D = D ^ F ^ 255;
    B = rotate_right(B, 2) + G - 1;
    A = rotate_bits(A) ^ D;
    C = rotate_right(C, 1) ^ A;
    D = B + 1 + D;
    E = rotate_bits(E) ^ B;
    G = F - G - 2;
    H = H ^ C;
}
```

Все действия здесь обратимы — воспользуемся [простым скриптом на Python](./extract_password.py) для того, чтобы вытащить пароль.

Пароль: [`2Re4l1Ty`](https://en.wikipedia.org/wiki/Second_Reality).

Вводим пароль в веб-интерфейс и получаем флаг:

![](./writeup/flag.png)

Флаг: **ugra_[commodore_64_basic_v2](https://www.c64-wiki.com/wiki/BASIC)\_[amiga_rulez](https://zxpress.ru/article.php?id=5467)_thml0wf0**

## Постмортем

`shl` — одноаргументная случайно, она должна была принимать immediate аргумент.
