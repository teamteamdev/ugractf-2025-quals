# Кошкоробка: Write-up

Дан сайт, куда можно заливать файлы за паролем и скачивать файлы по паролю. Уже залит флаг, но пароль к нему не дан.

Ходим по сайту и на странице загрузки нового файла видим следующий HTML-код:

```html
<form method="POST" enctype="multipart/form-data">
	<input type="hidden" name="id">
	<input type="hidden" name="password">
	<input type="file" name="file"> (no more than 256 KiB)<br>
	<input type="submit">
</form>
<script type="text/javascript">
	var n = BigInt(Math.random() * 1e100).toString(36);
	
	document.getElementsByName("id")[0].value = n.substr(0, 32);
	document.getElementsByName("password")[0].value = n.substr(32);
	
</script>
```

Таким образом, и ID, и пароль инициализируются на клиенте и порождены одним вызовом `Math.random()`. ID мы знаем. Сможем ли из него узнать пароль? Как ни странно, да.

Вспомним, что тип чисел в JavaScript по умолчанию — это 64-битные floating-point числа. Работает это так: хранится некоторое фиксированное количество значащих цифр, а именно, 52 бита (или 53, зависит от того, как считать), а также степень двойки (возможно, отрицательная), на которое это число надо умножить, чтобы получить истинное значение.

Формат весьма удобный, но имеет свои ограничения: после старших 52 битов в числе просто используются нулевые биты. Продемонстрируем это, посчитав в консоли битовое представление величины какого-нибудь очень большого случайного числа:

```javascript
> x = Math.random() * 1e100; x.toString(2) 
"10110111010001111110101000011010100100010110010101111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" 
```

Мало того, что оно оказалось целым, так ещё и много последних цифр — двоичные нули. Понятно, что погрешность такого представления очень большая, например:

```javascript
> x + 2 ** 274 === x
true

// А вот на одну степень больше уже не хватает
> x + 2 ** 275 === x
false 
```

Поэтому, чтобы однозначно задать `x`, достаточно знать его длину и значение с относительной погрешностью около `2^-53`.

В задании длина `n` — либо `BigInt(1e100).toString(36).length` (то есть `65`) символов, либо чуть меньше, что легко перебрать. А примерное значение `n` можно получить исходя из его префикса ID: это даёт `32` цифры в тридцатишестеричной системе счисления, то есть сильно большую точность, чем необходимая `2^-53`.

Решение:

```python
>>> n = int("1jwf2jl9l9qqps19f617hiewtrqbcfov" + "0" * 33, 36)  # примерное значение n
>>> n = int(float(n))  # округляем до ближайшего представимого float
>>> print(n)
6229789561217694485793531330525741685363354181670928509709220962332968886813105872214045881136054272
```

```javascript
> n = 6229789561217694485793531330525741685363354181670928509709220962332968886813105872214045881136054272.toString(36)
"1jwf2jl9l9qqps19f617hiewtrqbcfoviyzf75wv8asivrrbt3ysphbuf17o4g1kw"

> [n.substr(0, 32), n.substr(32)]
Array [ "1jwf2jl9l9qqps19f617hiewtrqbcfov", "iyzf75wv8asivrrbt3ysphbuf17o4g1kw" ]
//       ^ ID                                ^ пароль
```

Скачиваем флаг с таким паролем и радуемся жизни:

Флаг: **ugra_no_thoughts_only_meow_meow_rxpxrx7qmdtk**


## О решаемости задания

На генерирующем сервере `Math.random()` был модифицирован, чтобы возвращать числа, большие либо равные 0.1, чтобы `n` гарантированно имело достаточно большую длину. Это нужно по двум причинам:

- Было бы нечестно, если кому-то пришлось бы перебирать сильно больше длин, ведь кто-то мог бы делать это вручную и, не увидев правильного ответа, остановиться раньше времени.
- При коротких `n` точность может быть ниже `2^-53`. Это случается с чрезвычайно низкой вероятностью, но от этого случая также было решено отгородиться в целях увеличения предсказуемости.


## Постмортем

Почему задание за 100 баллов решили так мало команд? Какие только попытки мы ни увидели: люди заливали PHP-файлы, вставляли path traversal в ID, перезаписывали ID существующего файла с флагом, угадывали сид `Math.random()` по времени заливки файла…

Чтобы навести на мысль, что пароль нужно честно восстанавливать, а не искать дыру в сервисе, в середине соревнования мы добавили подсказку:

> Чтобы получить доступ к флагу, обязательно нужно ввести правильный пароль.

Правда, помогла она не сильно. Судя по всему, обстоятельством непреодолимой силы здесь выступило незнание участниками существования [IEEE-754](https://ru.wikipedia.org/wiki/IEEE_754) и того, что в целом представляют из себя числа с плавающей точкой. Ну что ж, надеемся, теперь вы узнали много нового.
