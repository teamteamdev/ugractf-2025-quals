# Прачечная: Write-up

В задании дано десктоп-приложение под Linux, похожее на Cookie Clicker:

![](writeup/first.png)

Поиграв, понимаем, что игра имеет следующие элементы:

- Есть текущее количество монет и скорость, с которой эти монеты растут.
- Есть моющие средства, которые увеличивают скорость автоматического роста, но дорожают с каждой покупкой.
- Есть источники денег, т.е. апгрейды, позволяющие перейти на следующий «уровень» и сильно ускорить добычу монет, но апгрейды дорожают быстрее, чем увеличивается скорость.

Посмотрим, что в бинарном файле. `readelf` видит необычно мало сегментов и ноль секций, `file` не говорит ничего интересного, но `binwalk` содержит упоминание некой UPX Team:

```shell
$ binwalk laundromat

                                                                                        /home/purplesyringa/sol/laundromat
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DECIMAL                            HEXADECIMAL                        DESCRIPTION
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
0                                  0x0                                ELF binary, 64-bit shared object, AMD X86-64 for System-V (Unix), little endian
3689983                            0x384DFF                           Copyright text: "Copyright (C) 1996-2024 the UPX Team. All Rights Reserved. $ "
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Analyzed 1 file for 85 file signatures (187 magic patterns) in 37.0 milliseconds
```

Мы — не UPX Team, мы [team Team], а [UPX](https://upx.github.io/) — это пакер для приложений. Устанавливаем его локально и узнаём, что он умеет их и распаковывать:

```shell
$ upx -d laundromat
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2025
UPX 5.0.0       Markus Oberhumer, Laszlo Molnar & John Reiser   Feb 20th 2025

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
  14591744 <-   4087576   28.01%   linux/amd64   laundromat

Unpacked 1 file.
```

Вот теперь появляются и символы, и прочее, и приложение становится возможно анализировать. Натравим `binwalk` ещё раз и заметим, что в приложении есть ZIP-архив:

```shell
$ binwalk -e laundromat 

                                                                                  /home/purplesyringa/sol/extractions/laundromat
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DECIMAL                            HEXADECIMAL                        DESCRIPTION
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
0                                  0x0                                ELF binary, 64-bit shared object, AMD X86-64 for System-V (Unix), little endian
9429933                            0x8FE3AD                           Copyright text: "copyrightcalled `Result::unwrap()` on an `Err` value/rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/"
10085056                           0x99E2C0                           SHA256 hash constants, little endian
10085072                           0x99E2D0                           SHA256 hash constants, little endian
10093764                           0x9A04C4                           CRC32 polynomial table, little endian
10121160                           0x9A6FC8                           CRC32 polynomial table, little endian
10183204                           0x9B6224                           ZIP archive, file count: 26, total size: 673220 bytes
13795850                           0xD2820A                           Copyright text: "copyright17hf675a0a2065d9d7eE"
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[+] Extraction of zip data at offset 0x9B6224 completed successfully
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Analyzed 1 file for 85 file signatures (187 magic patterns) in 147.0 milliseconds
```

(Также можно было заметить, что в ELF есть секция `.вложения`, как раз содержащая этот архив.)

В этом архиве лежат ассеты:

```shell
$ tree
.
└── assets
    ├── background.avif
    ├── coins
    │   ├── 1000.avif
    │   ├── 100.avif
    │   ├── 10.avif
    │   ├── 10c.avif
    │   ├── 1.avif
    │   ├── 1c.avif
    │   ├── 2000.avif
    │   ├── 200.avif
    │   ├── 2.avif
    │   ├── 5000.avif
    │   ├── 500.avif
    │   ├── 50.avif
    │   ├── 50c.avif
    │   ├── 5.avif
    │   ├── 5c.avif
    │   └── flag.avif
    ├── main.css
    ├── token.txt
    └── washers
        ├── dishwasher.avif
        ├── sponge.avif
        ├── toothbrush.avif
        └── washingmachine.avif

4 directories, 23 files
```

Заметим, что есть файл `token.txt`, содержащий что-то вроде `2t8ejw05ginoatku`, а в папке `coins` есть картинка флага, но самого флага нет. Поскольку монетки меняются при повышении уровня, можно сделать вывод, что итоговая цель игры — вероятно, проапгрейдиться много раз, и тогда нам дадут флаг.

Сделать это честно времени заведомо не хватит, придётся искать, как получить кучу денег иначе.

При перезапуске приложение показывает те же данные, что были при выходе. Где же оно их сохраняет? Не видно, чтобы оно создавало где-либо файлов. В Wireshark же можно увидеть, что открывается TLS-соединение к `laundromat.q.2025.ugractf.ru:3255`:

![Wireshark](writeup/wireshark.png)

Пакеты достаточно маленькие и отправляются редко, а не на каждое действие, поэтому, вероятно, сервер просто выступает облачным хранилищем, куда по таймеру сохраняются данные.

Если подключиться к серверу по TLS руками, он ничего не выведет, а на попытку отправить свои данные закроет соединение. Вероятно, нужно строго соблюдать некоторый протокол. А если попробовать перехватить взаимодействие настоящего клиента с сервером, подняв MITM-сервер, выдастся ошибка:

![UnknownIssuer](writeup/selfsigned.png)

То же самое происходит, даже если добавить сертификат в доверенные на своей машине. Видимо, программа сама проверяет сертификаты на корректность. Есть несколько путей это обойти.


## Выпустить подтверждённый сертификат

Если самоподписанный сертификат не сработал — можно выпустить настоящий, который будет подписан доверенными удостоверяющими центрами. Let’s Encrypt умеет выпускать сертификаты на домен, [используя только DNS](https://letsencrypt.org/docs/challenge-types/#dns-01-challenge), и в мире даже есть бесплатные DNS-хостинги, которые не дают вам никакой сервер, но позволяют произвольно настроить записи.

В качестве `A`-записи при этом спокойно можно поставить `127.0.0.1` и поднять сервер на своей машине, главное — настроить в нём полученный корректный сертификат. Но если сделать так и записать `127.0.0.1 laundromat.q.2025.ugractf.ru` в `/etc/hosts`, клиент выдаст новую ошибку:

![NotValidForName](writeup/notvalidforname.png)

Откуда клиент знает, что сертифкат выпущен на неправильный домен? Наверняка правильный домен должен быть забит в приложение, и действительно: в исполняемом файле есть строки `laundromat.q.2025.ugractf.ru:3255` и `laundromat.q.2025.ugractf.ru`. Заменив `laundromat.q.2025.ugractf.ru` в обоих местах на свой домен (при этом следя за тем, чтобы длины строк совпадали), наконец получаем успешный коннект. Теперь можно MITMить спокойно.


## Подменить корневой сертификат

Если корневые сертификаты забиты в само приложение, значит, их должно быть можно в нём найти. Скачаем, например, [корневой сертификат GlobalSign](https://support.globalsign.com/ca-certificates/root-certificates/globalsign-root-certificates). Целиком он как подстрока в приложении не находится, но вот public key `30 82 01 0A ... 03 01 00 01` там есть. Среди всех строк, которые показывает просмотрщик сертификатов в GNOME, в файле находятся только эти и строки из раздела _Subject Name_ (совпадающие с _Issuer Name_).

План: выпустим свой корневой сертификат, совпадающий с настоящим в этих двух полях, но с другим публичным ключом, заменим в программе публичный ключ на свой, а затем подпишем этим корневым сертификатом свой сертификат для `laundromat.q.2025.ugractf.ru`.

Выпустим самоподписанный сертификат для CA с той же длиной ключа и с правильным subject:

```
$ openssl genrsa 2048 >ca.key
$ openssl req -new -x509 -nodes -days 3653 -key ca.key -out ca.crt -subj '/C=BE/O=GlobalSign nv-sa/OU=Root CA/CN=GlobalSign Root CA/'
```

Заменим старый публичный ключ на новый. Сгенерируем CSR для своего сервера и подпишем его нашим CA:

```
$ openssl req -newkey rsa:2048 -nodes -days 365000 -keyout server.key -out server.csr
[здесь указать CN=moneylaundering.q.2025.ugractf.ru]

$ openssl x509 -req -days 365000 -set_serial 01 -in server.csr -out server.crt -CA ca.crt -CAkey ca.key
```

Поднимаем локальный сервер с таким сертификатом и плачем, потому что клиент его всё ещё не хочет принимать, считая самоподписанным. Где мы ошиблись? Возможно, мы не смогли корректно воспроизвести Subject Name? Воспользуемся [ридеорм ASN.1](https://lapo.it/asn1js/) и откроем два сертификата: свой и от GlobalSign. Найдите десять отличий:

![Real root](writeup/real_root.png)

![Fake root](writeup/fake_root.png)

В оригинальном сертификате тип значений `PrintableString`, а у нас — `UTF8String`. Видимо, строки поэтому считаются различными, хотя их содержимое и совпадает. Научить OpenSSL выдавать `PrintableString` ни у кого не получилось, поэтому придётся запатчить пару байтов с `0x0c` на `0x13` в выпущенном сертификате, ну или наоборот — в исполняемом файле. После этого ошибка уходит, но появляется другая: `NotValidForName`.

Что теперь не так? Гуглим ошибку и находим [ответ на StackOverflow](https://stackoverflow.com/a/76136847/5417677), где описано, как выпускать самоподписанные сертификаты правильно:

```shell
$ cat >server.ext <<EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
subjectAltName = @alt_names
[alt_names]
DNS.1 = moneylaundering.q.2025.ugractf.ru
EOF

$ openssl x509 -req -days 365000 -set_serial 01 -in server.csr -out server.crt -CA ca.crt -CAkey ca.key -CAcreateserial -extfile server.ext
```

После этого MITM уже работает.


## Извлечь сессионный ключ

Если посмотреть в символы или декомпилятор, можно увидеть, что программа написана на Rust и использует для работы с TLS библиотеку `rustls`. Она поддерживает [логирование сессионных ключей](https://docs.rs/rustls/latest/rustls/trait.KeyLog.html) через трейт `KeyLog`. В символах можно найти несколько символов с подстрокой `KeyLog`, как раз соответствующие методам `log` и `will_log` из него. Осталось подключиться отладчиком и поставить на них брейкпоинты: из `will_log` нужно вернуть `true` вместо дефолтного `false`, а на входе `log` достать из регистров секреты, после чего расшифровать TLS-соединение в Wireshark.


## Запатчить проверку

Наконец, можно нагуглить, что с `rustls` за проверку сертификатов отвечает крейт `webpki`, найти функцию [build_chain](https://github.com/briansmith/webpki/blob/94e6e88ed9f760952325f223d2296d1cff314cff/src/verify_cert.rs#L25) и подменить проверку в ней, заменив инструкцию `jz` из условия на `jnz`:

```c
auStack_5f8[0] = 0x8000000000000001;
uStack_500 = 0x8000000000000001;
uStack_408 = 0x8000000000000001;
uStack_310 = 0x8000000000000001;
uStack_218 = 0x8000000000000001;
uStack_120 = 0x8000000000000001;
uStack_20 = 0;
uStack_610 = 100;
uStack_608 = 200000;
uStack_600 = 250000;
uStack_28 = param_3;
_ZN6webpki11verify_cert12ChainOptions17build_chain_inner17hf62b45b377be1b24E.llvm.4181823707565637 744
          (acStack_620,param_2,auStack_5f8);
if (acStack_620[0] == '\0') {
  memcpy(param_1,auStack_5f8,0x5d0);
  param_1[0xba] = uStack_20;
  param_1[0xbb] = param_3;
  param_1[0xbc] = uStack_618;
}
else {
  *(undefined *)(param_1 + 1) = uStack_61e;
  *param_1 = 0x8000000000000003;
  _ZN4core3ptr53drop_in_place$LT$webpki..verify_cert..PartialPath$GT$17h67617e4d4870ba78E.llvm.418 1823707565637744
            (auStack_5f8);
}
return param_1;
```

После этого заработают любые сертификаты.

---

Так или иначе, на этот момент у нас есть дамп общения клиента и сервера:

```
-> a1 69 41 75 74 68 6f 72 69 7a 65 70 32 74 38 65 6a 77 30 35 67 69 6e 6f 61 74 6b 75
   \xa1iAuthorizep2t8ejw05ginoatku
<- f6
   \xf6
-> 64 4c 6f 61 64
   dLoad
<- a4 65 6d 6f 6e 65 79 fb 40 18 a3 d7 0a 3d 70 42 69 62 61 73 65 5f 72 61 74 65 02 65 73 74 61 67 65 00 6d 77 61 73 68 65 72 5f 63 6f 75 6e 74 73 84 02 00 00 00
   \xa4emoney\xfb@\x18\xa3\xd7\n=pBibase_rate\x02estage\x00mwasher_counts\x84\x02\x00\x00\x00
```

Протокол бинарный, но, судя по наличию названий ключей `money`, `base_rate` и т.п., включает в себя схему. Понадеемся, что авторы не написали свой протокол со схемой специально для одной задачи, и посмотрим, не используется ли какая-то стандартная. Но msgpack, bencode — всё не то.

Заглянем повнимательнее в код. Есть класс `Communicator`, у которого есть методы, внутри которых есть вызовы функций из крейта `ciborium`. Гуглим его и понимаем, что это библиотека для работы с [CBOR](https://cbor.io/).  Попробуем декодировать данные таким форматом:

```python
import cbor2
print(cbor2.loads(b"\xa1iAuthorizep2t8ejw05ginoatku"))
print(cbor2.loads(b"\xf6"))
print(cbor2.loads(b"dLoad"))
print(cbor2.loads(b"\xa4emoney\xfb@\x18\xa3\xd7\n=pBibase_rate\x02estage\x00mwasher_counts\x84\x02\x00\x00\x00"))
```

```python
{'Authorize': '2t8ejw05ginoatku'}
None
Load
{'money': 6.159999999999913, 'base_rate': 2, 'stage': 0, 'washer_counts': [2, 0, 0, 0]}
```

Действительно! Если в декомпилятор лезть не хотелось, можно было обойтись символами. После деманглинга часть в символе до первого `::` — это название крейта. Так мы можем вытащить названия всех крейтов, которые используются программой:

```shell
$ nm -C laundromat | tr -d '<' | grep :: | cut -d' ' -f3 | cut -d: -f1 | sort -u
()
[A]
A
addr2line
adler
aes
alloc
ashpd
async_broadcast
aws_lc_rs
...
cfb
char
ciborium
ciborium_ll
compiler_builtins
*const
constant_time_eq
...
```

Среди всего этого мусора с сериализацией связаны только два крейта: `cfb` и `ciborium`. Последний нам как раз и нужен.

Так или иначе, из расшифровки остального траффика мы узнаём о команде `Save`. Осталось подключиться к серверу и сохранить себе много денег, а затем подключиться нормальным клиентом и купить все апгрейды, после чего выдастся флаг.

Флаг: **ugra_keep_your_hands_clean_469dprvupqwj**


## Античит

В задании был встроен античит. Если запустить программу под _gdb_, ей постоянно приходил сигнал `SIGTRAP`. Если сказать _gdb_ пробрасывать его процессу (командой `handle SIGTRAP nostop noprint noignore`), _gdb_ начинал работать некорректно и становился бесполезным. Если же сказать _gdb_ его игнорировать, выводился следующий текст:

```
В вашей системе обнаружены читы!
Если злонамеренные действия с вашей стороны повторятся, нам придется ограничивать вам доступ к игре.
Если вы считаете, что читов на вашем устройстве нет, обратитесь в поддержку.
```

Эту проверку можно было выпатчить, но после этого активировался более хитрый античит: программа под отладчиком начинала некорректно сохранять данные, и причина этого не так очевидна при декомпиляции. Таким образом, даже если найти место в памяти клиента, которое отвечает за количество денег, и эту величину потом запатчить отладчиком, она не сохранится на сервер.
